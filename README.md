<div align="center">
  <h1>Enrollment Management System UNSA (By Dexo Corp)</h1>
</div>

<div align="center">

[![Typing SVG](https://readme-typing-svg.demolab.com?font=Fira+Code&weight=500&size=18&pause=500&color=BBF7F7&width=300&lines=%F0%9F%92%BB+DDD+%2B+Microservices+%F0%9F%92%BB;%F0%9F%92%BB+Software+Engineer+III+%F0%9F%92%BB)](https://git.io/typing-svg)

</div>

<div align="center">
  
  <!-- Tecnologies -->
  ![.Net](https://img.shields.io/badge/.NET-5C2D91?style=for-the-badge&logo=.net&logoColor=white)
  ![C#](https://img.shields.io/badge/c%23-%23239120.svg?style=for-the-badge&logo=csharp&logoColor=white)
  ![MySQL](https://img.shields.io/badge/mysql-4479A1.svg?style=for-the-badge&logo=mysql&logoColor=white)
  ![MongoDB](https://img.shields.io/badge/MongoDB-%234ea94b.svg?style=for-the-badge&logo=mongodb&logoColor=white)
  ![RabbitMQ](https://img.shields.io/badge/Rabbitmq-FF6600?style=for-the-badge&logo=rabbitmq&logoColor=white)
  ![Docker](https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&logo=docker&logoColor=white)
  ![Postman](https://img.shields.io/badge/Postman-FF6C37?style=for-the-badge&logo=postman&logoColor=white)
  ![Swagger](https://img.shields.io/badge/-Swagger-%23Clojure?style=for-the-badge&logo=swagger&logoColor=white)
  ![React](https://img.shields.io/badge/react-%2320232a.svg?style=for-the-badge&logo=react&logoColor=%2361DAFB)
  ![TypeScript](https://img.shields.io/badge/typescript-%23007ACC.svg?style=for-the-badge&logo=typescript&logoColor=white)
  <!-- ![Redux](https://img.shields.io/badge/redux-%23593d88.svg?style=for-the-badge&logo=redux&logoColor=white) -->
  <!-- ![SASS](https://img.shields.io/badge/SASS-hotpink.svg?style=for-the-badge&logo=SASS&logoColor=white) -->

  <!-- Badges -->
  ![Build Status](https://img.shields.io/badge/build-passing-77dd77)
  ![Microservices](https://img.shields.io/badge/microservices-7%20services-ffb347)
  [![Commits](https://badgen.net/github/commits/ShinjiMC/Enrollment-Management-System-UNSA/main)]()
  ![Version](https://img.shields.io/badge/version-1.0.0-b39eb5)
  ![License](https://img.shields.io/badge/license-MIT-cfcfc4)

</div>


## 1. Descripción

### Equipo de Desarrollo
- **Nombre del Equipo:** _Dexo Corp_
- **Integrantes:**
  - Mogollon Caceres Sergio Daniel
  - Davis Coropuna Leon Felipe
  - Apaza Apaza Nelzon Jorge
  - Lupo Condori Avelino
  - Maldonado Casilla Braulio Nayap
  - Parizaca Mozo Paul Antony
  - Huaman Coaquira Luciana Julissa

### Cliente
- **Organización:** Universidad Nacional de San Agustín (UNSA)

### Propósito del Proyecto
El propósito de este proyecto es desarrollar un Sistema de Gestión de Matrículas (SGM) que optimice los procesos de inscripción y gestión de matrículas de los estudiantes de la Universidad Nacional de San Agustín (UNSA). Este sistema tiene como objetivo ser escalable, seguro y fácil de usar, basado en una arquitectura moderna de microservicios.


## 2. Requisitos y Features

### 2.1. Requisitos Funcionales y No Funcionales

**Requisitos Funcionales:**
- RF1: Gestionar Autenticación
- RF2: Gestionar Usuarios
- RF3: Gestionar Cursos
- RF4: Gestionar Horarios
- RF5: Realizar Matrícula
- RF6: Generar Reportes de Matrícula
- RF7: Gestionar Escuelas
- RF8: Gestionar Notificaciones
- RF9: Gestionar Pagos
- RF10: Gestionar Cupos

**Requisitos No Funcionales:**
- RNF1: Usabilidad
- RNF2: Rendimiento
- RNF3: Seguridad
- RNF4: Escalabilidad
- RNF5: Disponibilidad
- RNF6: Mantenibilidad
- RNF7: Compatibilidad

### 2.2. Features

<details open>
  <summary><strong>Gestionar Autenticación</strong></summary>
  <ul>
    <li>Feature 1.1: Autenticación de Usuarios</li>
    <li>Feature 1.2: Recuperación de Contraseña</li>
  </ul>
</details>
<details>
  <summary><strong>Gestionar Usuarios</strong></summary>
  <ul>
    <li>Feature 2.1: Creación de Usuarios</li>
    <li>Feature 2.2: Actualización de Usuarios</li>
    <li>Feature 2.3: Eliminación de Usuarios</li>
  </ul>
</details>
<details>
  <summary><strong>Gestionar Cursos</strong></summary>
  <ul>
    <li>Feature 3.1: Creación de Cursos</li>
    <li>Feature 3.2: Actualización de Cursos</li>
    <li>Feature 3.3: Eliminación de Cursos</li>
  </ul>
</details>
<details>
  <summary><strong>Gestionar Horarios</strong></summary>
  <ul>
    <li>Feature 4.1: Creación de Horarios</li>
    <li>Feature 4.2: Actualización de Horarios</li>
    <li>Feature 4.3: Eliminación de Horarios</li>
  </ul>
</details>
<details>
  <summary><strong>Realizar Matrícula</strong></summary>
  <ul>
    <li>Feature 5.1: Inscripción de Estudiantes</li>
    <li>Feature 5.2: Actualización de Matrícula</li>
    <li>Feature 5.3: Cancelación de Matrícula</li>
  </ul>
</details>
<details>
  <summary><strong>Generar Reportes de Matrícula</strong></summary>
  <ul>
    <li>Feature 6.1: Reporte de Inscripciones</li>
    <li>Feature 6.2: Reporte de Pagos</li>
  </ul>
</details>
<details>
  <summary><strong>Gestionar Escuelas</strong></summary>
  <ul>
    <li>Feature 7.1: Creación de Escuelas</li>
    <li>Feature 7.2: Actualización de Escuelas</li>
    <li>Feature 7.3: Eliminación de Escuelas</li>
  </ul>
</details>
<details>
  <summary><strong>Gestionar Notificaciones</strong></summary>
  <ul>
    <li>Feature 8.1: Envío de Notificaciones</li>
    <li>Feature 8.2: Gestión de Plantillas</li>
  </ul>
</details>
<details>
  <summary><strong>Gestionar Pagos</strong></summary>
  <ul>
    <li>Feature 9.1: Procesamiento de Pagos</li>
    <li>Feature 9.2: Verificación de Pagos</li>
  </ul>
</details>
<details>
  <summary><strong>Gestionar Cupos</strong></summary>
  <ul>
    <li>Feature 10.1: Asignación de Cupos</li>
    <li>Feature 10.2: Actualización de Cupos</li>
    <li>Feature 10.3: Cancelación de Cupos</li>
  </ul>
</details>

## 3. Arquitectura del Sistema
Descripción general de la arquitectura de microservicios.

### 3.1. Diagrama General

<p align="center">
  <img src="resources/arquitecturav1.png" alt="Arquitectura" width="720px" />
</p>


### 3.2. Lista de Microservicios
- [Microservicio de Autenticación](./payments-microservice/README.md)
- [Microservicio de Usuarios](./payments-microservice/README.md)
- [Microservicio de Cursos](./payments-microservice/README.md)
- [Microservicio de Matrícula](./payments-microservice/README.md)
- [Microservicio de Escuelas](./payments-microservice/README.md)
- [Microservicio de Notificaciones](./payments-microservice/README.md)
- [Microservicio de Pagos](./payments-microservice/README.md)

## 4. Implementación

### 4.1. Tecnologías Utilizadas

- **Backend:**
  - `.NET`: Framework de desarrollo para la implementación de los microservicios backend.
  - `C#`: Lenguaje de programación para el desarrollo de los microservicios backend.
  - `Entity Framework Core`: ORM para el mapeo de objetos a relaciones.
  - `NUnit`: Framework de pruebas unitarias para las pruebas del backend.
- **Frontend:**
  - `React`: Biblioteca de JavaScript para la creación de interfaces de usuario declarativas.
  - `Redux`: Librería para la gestión del estado de la aplicación.
  - `TypeScript`: Lenguaje de programación superconjunto de JavaScript con tipado estático.
  - `SASS`: Preprocesador de CSS para la creación de estilos CSS más organizados y mantenibles.
- **Mensajería:**
  - `RabbitMQ`: Sistema de mensajería asíncrona para la comunicación entre microservicios.
- **Base de Datos:**
  - `Mysql`: Sistema de gestión de bases de datos relacionales.
  - `Mongodb`: Base de datos NoSQL de código abierto.

### 4.2. Clean Code

El código ha sido desarrollado siguiendo las mejores prácticas de clean code para asegurar su mantenibilidad, legibilidad y escalabilidad. Algunos de los principios aplicados incluyen:

- **Nombres significativos:** Uso de nombres claros y descriptivos para variables, funciones y clases.
- **Funciones pequeñas:** Funciones que realizan una única tarea específica.
- **Comentarios útiles:** Comentarios que explican el "por qué" detrás de una decisión de código.
- **Manejo de errores:** Manejo adecuado de excepciones y errores para prevenir fallos inesperados.

### 4.3. Principios SOLID

El diseño del sistema sigue los principios SOLID para garantizar una arquitectura robusta y flexible:

- **S - Principio de Responsabilidad Única (Single Responsibility Principle):**
  Cada clase debe tener una única responsabilidad. Por ejemplo, una clase `UserService` se encarga únicamente de la lógica relacionada con los usuarios.
  
  ```csharp
  public class UserService
  {
      private readonly IUserRepository _userRepository;

      public UserService(IUserRepository userRepository)
      {
          _userRepository = userRepository;
      }

      public void AddUser(User user)
      {
          // Lógica para añadir un usuario
      }
  }
  ```

- **O - Principio de Abierto/Cerrado (Open/Closed Principle):**
  Las clases deben estar abiertas para extensión, pero cerradas para modificación. Utilizamos la herencia y la interfaz para extender el comportamiento sin modificar el código existente.

  ```csharp
  public interface IPaymentProcessor
  {
      void ProcessPayment(Payment payment);
  }

  public class CreditCardPaymentProcessor : IPaymentProcessor
  {
      public void ProcessPayment(Payment payment)
      {
          // Lógica para procesar pagos con tarjeta de crédito
      }
  }
  ```

- **L - Principio de Sustitución de Liskov (Liskov Substitution Principle):**
  Las clases derivadas deben ser sustituibles por sus clases base. Las clases hijas deben implementar completamente la funcionalidad esperada por la clase padre.

  ```csharp
  public class Rectangle
  {
      public virtual int Width { get; set; }
      public virtual int Height { get; set; }

      public int Area => Width * Height;
  }

  public class Square : Rectangle
  {
      public override int Width
      {
          set { base.Width = base.Height = value; }
      }

      public override int Height
      {
          set { base.Width = base.Height = value; }
      }
  }
  ```

- **I - Principio de Segregación de Interfaces (Interface Segregation Principle):**
  Una clase no debería estar forzada a implementar interfaces que no usa. Dividimos las interfaces grandes en otras más pequeñas y específicas.

  ```csharp
  public interface IPrint
  {
      void Print();
  }

  public interface IScan
  {
      void Scan();
  }

  public class MultiFunctionPrinter : IPrint, IScan
  {
      public void Print()
      {
          // Implementación de imprimir
      }

      public void Scan()
      {
          // Implementación de escanear
      }
  }
  ```

- **D - Principio de Inversión de Dependencia (Dependency Inversion Principle):**
  Las dependencias deben ir desde los módulos de alto nivel hacia los módulos de bajo nivel. Utilizamos la inyección de dependencias para implementar este principio.

  ```csharp
  public interface IElectronicBillService
  {
      Task<ElectronicBillDto> CreateElectronicBill(ElectronicBillDto electronicBillDto);
      Task<ElectronicBillDto> GetElectronicBillById(string electronicBillId);
      Task<List<ElectronicBillDto>> GetElectronicBills();
      Task<bool> UpdateElectronicBillStatus(string electronicBillId, string status);
  }

  public class ElectronicBillService : IElectronicBillService
  {
    private readonly IElectronicBillDomainService _electronicBillDomainService;

    public ElectronicBillService(IElectronicBillDomainService electronicBillDomainService)
    {
        _electronicBillDomainService = electronicBillDomainService;
    }

    public async Task<ElectronicBillDto> CreateElectronicBill(ElectronicBillDto electronicBillDto)
    {
        var electronicBill = await _electronicBillDomainService.CreateElectronicBill(
            electronicBillDto.StudentId,
            new Money(electronicBillDto.TotalAmount.Amount, electronicBillDto.TotalAmount.Currency),
            electronicBillDto.DueDate,
            electronicBillDto.Items?.ConvertAll(item => new ElectronicBillItem
            {
                ElectronicBillItemId = item.ElectronicBillItemId,
                Description = item.Description,
                Amount = new Money(item.Amount.Amount, item.Amount.Currency)
            }) ?? new List<ElectronicBillItem>()
        );

        return ElectronicBillMapper.ToDto(electronicBill);
    }
  }
  ```

## 5. Instalación y Configuración

### 5.1. Requisitos Previos
- **Requisitos del sistema**:
  - Sistema operativo compatible (Windows, macOS, Linux).
  - `.NET 8` SDK instalado.
  - `Docker` y Docker Compose instalados (para despliegue en contenedores).
  - `MySQL` (Base de datos relacional disponible de manera local o en la nube)
  - `MongoDB` (Base de datos no relacional disponible de manera local o en la nube)

- **Software necesario**:
  - `Git` para el control de versiones.
  - `Visual Studio Code` y C# Dev Kit (extensiones para trabajar en el entorno de .NET).
  - Herramientas de línea de comandos (bash, PowerShell, etc.).

### 5.2. Instrucciones

#### **1. Crear Solución**

```bash
mkdir users-microservice && cd users-microservice
dotnet new sln
```

Esta sección crea una nueva solución .NET en un directorio específico.

#### **2. Crear Proyecto Fuente**

```bash
mkdir src && cd src && dotnet new web
```

Esta sección crea un nuevo proyecto web dentro de la carpeta `src`.

#### **3. Crear Proyecto de Pruebas**

```bash
mkdir test && cd test && dotnet new nunit
```

Esta sección crea un nuevo proyecto de pruebas usando NUnit dentro de la carpeta `test`.

- **Vincular el Proyecto de Pruebas con el Proyecto Fuente**:
  ```bash
  dotnet add reference ../src/src.csproj
  ```

#### **4. Vincular Subproyectos al Proyecto Base**

- Navegar a la raíz del `proyecto base`.
- **Vincular Proyecto Fuente con el Proyecto Base**:
  ```bash
  dotnet sln add src/src.csproj
  ```
- **Vincular Proyecto de Pruebas con el Proyecto Base**:
  ```bash
  cd ..
  dotnet sln add test/test.csproj
  ```

#### **5. Instalar Dependencias**

En `src/`:

- `EntityFramework Core` para ejecutar comandos de dotnet ef en CLI:
  ```bash
  dotnet tool install --global dotnet-ef
  ```
- `EntityFrameworkCore.Design` para migraciones:
  ```bash
  dotnet add package Microsoft.EntityFrameworkCore.Design --version 9.0.0-preview.1.24081.2
  ```
- Dependencia `Pomelo.EntityFrameworkCore.MySql` para MySQL:
  ```bash
  dotnet add package Pomelo.EntityFrameworkCore.MySql --version 9.0.0-preview.1
  ```
- Dependencia `MongoDB.Driver` para MongoDB:
  ```bash
  dotnet add package MongoDB.Driver --version 2.28.0
  ```
- Dependencia `Microsoft.AspNetCore.Authentication.JwtBearer` para tokenización JWT:
  ```bash
  dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer --version 8.0.5
  ```

En `test/`:

- `coverlet.collector` para reportes de cobertura:
  ```bash
  dotnet add package coverlet.collector --version 6.0.2
  ```
- Dependencia `Moq` para mocking:
  ```bash
  dotnet add package Moq --version 4.20.70
  ```

#### **6. Añadir Migraciones**

Navegar a la carpeta `src/`:

```bash
cd src/
```

Añadir una nueva migración:

```bash
dotnet ef migrations add NameMigrate
```

Actualizar la base de datos con la nueva migración:

```bash
dotnet ef database update
```

#### **7. Ejecutar la Aplicación**

```bash
dotnet run --project src/src.csproj
```

#### **8. Ejecutar Pruebas**

```bash
dotnet test
```

#### **9. Construir la Aplicación**

```bash
dotnet build src/src.csproj --configuration Release
```

#### **10. Cobertura**

```bash
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=opencover /p:CoverletOutput=../../coverage # no funciona
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=opencover --output coverage # funciona pero con advertencias
```

## 6. Configuración de Pruebas

### Descripción de las Pruebas Implementadas
Las pruebas han sido diseñadas para asegurar la calidad del código y la funcionalidad del microservicio de gestión de matrículas. Se incluyen pruebas unitarias, pruebas de integración y pruebas funcionales. Las pruebas cubren escenarios de autenticación, manejo de usuarios, gestión de cursos, y más.

### Cómo Ejecutar las Pruebas

#### **1. Crear Proyecto de Pruebas**

```bash
mkdir test && cd test && dotnet new nunit
```

#### **2. Vincular el Proyecto de Pruebas con el Proyecto Fuente**

```bash
dotnet add reference ../src/src.csproj
```

#### **3. Instalar Dependencias de Pruebas**

- `coverlet.collector` para reportes de cobertura:
  ```bash
  dotnet add package coverlet.collector --version 6.0.2
  ```
- Dependencia `Moq` para mocking:
  ```bash
  dotnet add package Moq --version 4.20.70
  ```

#### **4. Ejecutar las Pruebas**

```bash
dotnet test
```

#### **5. Cobertura de Código**

Para obtener reportes de cobertura de código, ejecutar:

```bash
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=opencover --output coverage
```

## 7. Despliegue

### ***A. Dockerizacion***

1. **Crear el Dockerfile**: Asegúrate de que el Dockerfile se encuentra en la raíz del proyecto.

    ```dockerfile
    # Utilizar la imagen oficial de .NET como imagen base
    FROM mcr.microsoft.com/dotnet/aspnet:7.0 AS base
    WORKDIR /app
    EXPOSE 80

    # Utilizar la imagen oficial de .NET SDK como imagen base para compilación
    FROM mcr.microsoft.com/dotnet/sdk:7.0 AS build
    WORKDIR /src
    COPY ["src/YourProject.csproj", "src/"]
    RUN dotnet restore "src/YourProject.csproj"
    COPY . .
    WORKDIR "/src/src"
    RUN dotnet build "YourProject.csproj" -c Release -o /app/build

    FROM build AS publish
    RUN dotnet publish "YourProject.csproj" -c Release -o /app/publish

    FROM base AS final
    WORKDIR /app
    COPY --from=publish /app/publish .
    ENTRYPOINT ["dotnet", "YourProject.dll"]
    ```

2. **Construir la imagen de Docker**: Ejecuta el siguiente comando en la terminal desde la raíz del proyecto donde se encuentra el Dockerfile.

    ```bash
    docker build -t yourproject-image .
    ```

3. **Crear y ejecutar un contenedor**: Usa el siguiente comando para crear y ejecutar un contenedor a partir de la imagen recién creada.

    ```bash
    docker run -d -p 8080:80 --name yourproject-container yourproject-image
    ```

### ***B. Entornos de despliegue***

#### ***a) Desarrollo***

Para el entorno de desarrollo, puedes utilizar Docker Compose para gestionar múltiples contenedores. Crea un archivo `docker-compose.yml` con el siguiente contenido:

```yaml
version: '3.4'

services:
  yourproject:
    image: yourproject-image
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:80"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
```

Luego, ejecuta:

```bash
docker-compose up
```

#### ***b) Pruebas***

Para el entorno de pruebas, puedes modificar el archivo `docker-compose.yml` para incluir servicios adicionales como bases de datos o servicios de prueba.

```yaml
version: '3.4'

services:
  yourproject:
    image: yourproject-image
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:80"
    environment:
      - ASPNETCORE_ENVIRONMENT=Testing
  db:
    image: mysql:latest
    environment:
      MYSQL_ROOT_PASSWORD: yourpassword
      MYSQL_DATABASE: yourdatabase
    ports:
      - "3306:3306"
```

Ejecuta:

```bash
docker-compose -f docker-compose.yml up --build
```

#### ***c) Producción***

Para el entorno de producción, asegúrate de que todas las configuraciones y secretos están correctamente configurados. Puedes usar servicios de orquestación como Kubernetes para gestionar el despliegue a escala.

```yaml
version: '3.4'

services:
  yourproject:
    image: yourproject-image
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "80:80"
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
```

Ejecuta:

```bash
docker-compose -f docker-compose.prod.yml up --build -d
```

## 8. Licencia
This project is licensed under [Creative Commons Atribución-NoComercial-CompartirIgual 4.0 Internacional](http://creativecommons.org/licenses/by-nc-sa/4.0/):

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
  <img alt="Licencia Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
</a>

## 9. Referencias

[1] W. by Iamprovidence, **“Backend side architecture evolution (N-layered, DDD, Hexagon, Onion, Clean Architecture)”**, Medium, 27-jun-2023. [En línea]. Disponible en: [https://medium.com/@iamprovidence/backend-side-architecture-evolution-n-layered-ddd-hexagon-onion-clean-architecture-643d72444ce4](https://medium.com/@iamprovidence/backend-side-architecture-evolution-n-layered-ddd-hexagon-onion-clean-architecture-643d72444ce4).

[2] C. Ramalingam, **“Building domain driven microservices - Walmart global tech blog - medium”**, Walmart Global Tech Blog, 01-jul-2020. [En línea]. Disponible en: [https://medium.com/walmartglobaltech/building-domain-driven-microservices-af688aa1b1b8](https://medium.com/walmartglobaltech/building-domain-driven-microservices-af688aa1b1b8).

[3] J. Loscalzo, **“Domain Driven Design: principios, beneficios y elementos — Segunda Parte”**, Medium, 18-jun-2018. [En línea]. Disponible en: [https://medium.com/@jonathanloscalzo/domain-driven-design-principios-beneficios-y-elementos-segunda-parte-337d77dc8566](https://medium.com/@jonathanloscalzo/domain-driven-design-principios-beneficios-y-elementos-segunda-parte-337d77dc8566).

[4] P. Martinez, **“Domain-Driven Design: Everything you always wanted to know”**, SSENSE-TECH, 15-may-2020. [En línea]. Disponible en: [https://medium.com/ssense-tech/domain-driven-design-everything-you-always-wanted-to-know-about-it-but-were-afraid-to-ask-a85e7b74497a](https://medium.com/ssense-tech/domain-driven-design-everything-you-always-wanted-to-know-about-it-but-were-afraid-to-ask-a85e7b74497a).


<!-- ## **Principios Solid**

- **Single Responsibility Principle (SRP):**
Cada clase o módulo debe tener una única responsabilidad o razón para cambiar. En otras palabras, una clase debe estar enfocada en una sola tarea o funcionalidad, lo que facilita su comprensión, mantenimiento y prueba. Si una clase tiene más de una responsabilidad, es probable que los cambios en una responsabilidad afecten a las otras, lo que puede llevar a errores y un código más difícil de gestionar.

- **Open/Closed Principle (OCP):**
Las entidades de software (clases, módulos, funciones, etc.) deben estar abiertas para la extensión, pero cerradas para la modificación. Esto significa que el comportamiento de una clase debe poder extenderse sin modificar su código fuente original. Este principio promueve el uso de la herencia, la composición y otros patrones de diseño para agregar nuevas funcionalidades, lo que reduce el riesgo de introducir errores en el código existente.

- **Liskov Substitution Principle (LSP):**
Las subclases deben ser sustituibles por sus superclases sin alterar el comportamiento correcto del programa. Esto implica que las clases derivadas deben ser completamente intercambiables con sus clases base, cumpliendo con el contrato establecido por la clase base. Las subclases no deben cambiar la funcionalidad esperada ni violar las expectativas del usuario de la clase base.

- **Interface Segregation Principle (ISP):**
Los clientes no deben estar obligados a depender de interfaces que no utilizan. En lugar de tener una única interfaz grande y general, es preferible tener múltiples interfaces específicas y pequeñas. Esto permite que los clientes dependan solo de los métodos que realmente necesitan, reduciendo las dependencias innecesarias y haciendo que el código sea más fácil de modificar y mantener.

- **Dependency Inversion Principle (DIP):**
Los módulos de alto nivel no deben depender de módulos de bajo nivel, sino que ambos deben depender de abstracciones. Además, las abstracciones no deben depender de los detalles, sino que los detalles deben depender de las abstracciones. Este principio promueve el uso de interfaces o clases abstractas para reducir el acoplamiento entre componentes, facilitando la modificación y prueba del código. -->

<!-- 

## 6. **Configuraciones** ***(ASP Project With NUnit Test)***

### Project Setup

#### **1. Create Solution**

```bash
mkdir users-microservice && cd users-microservice
dotnet new sln
```

#### **2. Create Source Project**

```bash
mkdir src && cd src && dotnet new web
```

#### **3. Create Test Project**

```bash
mkdir test && cd test && dotnet new nunit
```
- Link Test Project with Source Project
  ```bash
  dotnet add reference ../src/src.csproj
  ```

#### **4. Link Subprojects to Base Project**

- Go to the root of the `base project`
- Link Source Project with Base Project
  ```bash
  dotnet sln add src/src.csproj
  ```
- Link Test Project with Base Project
  ```bash
  cd ..
  dotnet sln add test/test.csproj
  ```

#### **5. Install Dependencies**

In `src/`

- `EntityFramework Core` for run dotnet ef commands in CLI:
  ```bash
  dotnet tool install --global dotnet-ef
  ```
- `EntityFrameworkCore.Design` for migrations:
  ```bash
  dotnet add package Microsoft.EntityFrameworkCore.Design --version 9.0.0-preview.1.24081.2
  ```
- `Pomelo.EntityFrameworkCore.MySql` dependency for MySql:
  ```bash
  dotnet add package Pomelo.EntityFrameworkCore.MySql --version 9.0.0-preview.1
  ```
- `MongoDB.Driver` dependency for MongoDB:
  ```bash
  dotnet add package MongoDB.Driver --version 2.28.0
  ```
- `Microsoft.AspNetCore.Authentication.JwtBearer` dependency for JWT Tokenization:
  ```bash
  dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer --version 8.0.5
  ```
In `test/`
- `coverlet.collector` for Cover Reports:
  ```bash
  dotnet add package coverlet.collector --version 6.0.2
  ```
- `Moq` dependency for mocking:
  ```bash
  dotnet add package Moq --version 4.20.70
  ```

#### **6. Add Migrations**

```bash
cd src/
```

```bash
dotnet ef migrations add NameMigrate
```

```bash
dotnet ef database update
```

#### **6. Run App**

```bash
dotnet run --project src/src.csproj
```

#### **7. Run Test**

```bash
dotnet test
```

#### **8. Build App**

```bash
dotnet build src/src.csproj --configuration Release
```

#### **9. Coverage**

```bash
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=opencover /p:CoverletOutput=../../coverage # no func
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=opencover --output coverage # si func pero warning
```

#### **10. SonarScanner Analysis**
```bash
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=opencover
          echo "SONAR SCANNER BEGIN ---------------"
          ../.sonar/scanner/dotnet-sonarscanner begin /k:"i-am-sergio_enrollapp" /o:"i-am-sergio" /d:sonar.token="${{ secrets.SONAR_TOKEN }}" /d:sonar.host.url="https://sonarcloud.io" /d:sonar.cs.opencover.reportsPaths="**/test/coverage.opencover.xml"
          dotnet build
          echo "SONAR SCANNER END ---------------"
          ../.sonar/scanner/dotnet-sonarscanner end /d:sonar.token="${{ secrets.SONAR_TOKEN }}"
``` -->
